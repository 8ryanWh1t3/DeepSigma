#!/usr/bin/env python3
"""Generate FinServ CoherenceOps workbook (BOOT-compliant).

Creates a CDS-pattern workbook with 7 canonical named tables populated
with financial services governance sample data (Apex Capital Partners).

Requires: openpyxl (pip install openpyxl)

Usage:
    python tools/generate_finserv_cds_workbook.py
"""

from __future__ import annotations

import datetime
import sys
from pathlib import Path

try:
    import openpyxl
    from openpyxl import Workbook
    from openpyxl.styles import Alignment, Font
    from openpyxl.worksheet.table import (
        Table,
        TableStyleInfo,
    )
except ImportError:
    print(
        "ERROR: openpyxl is required. "
        "Install with: pip install openpyxl"
    )
    sys.exit(1)

REPO_ROOT = Path(__file__).resolve().parent.parent
OUTPUT = (
    REPO_ROOT
    / "templates"
    / "creative_director_suite"
    / "FinServ_CoherenceOps.xlsx"
)

TODAY = datetime.date.today().isoformat()

DESKS = ["Equities", "Fixed Income", "Derivatives"]
DOMAINS = ["RMC", "REG", "TRD", "FIN"]

BOOT_TEXT = f"""\
BOOT! METADATA
version: 0.4.0
ttl_hours_default: 168
risk_lane_default: ADVISORY
schema_ref: docs/excel-first/TABLE_SCHEMAS.md
owner: RiskOps Team

=== FINSERV RISKOPS — COHERENCE OPS WORKBOOK v1.0 ===

YOU ARE: RiskOps Copilot (Coherence Ops: Truth · Reasoning · Memory)
INSTITUTION: Apex Capital Partners (fictional)
DESKS: Equities, Fixed Income, Derivatives
DOMAINS: RMC (Risk Management/Compliance), REG (Regulatory), \
TRD (Trading/Operations), FIN (Financial)

OPENING MOVE:
1) Read this workbook's tables (tblTimeline, tblDeliverables, \
tblClaims, tblAssumptions, tblDLR, tblPatchLog, tblCanonGuardrails).
2) Then ask: "What Would You Like To Do Today?" and show the menu.

MENU (reply with a number):
1) Build/Update Risk Claims
2) Refresh Assumptions + Half-Life (market, regulatory, model)
3) Detect Drift + Root Cause (VaR, limits, compliance)
4) Propose Patch Options
5) Canon Audit (Basel III, SOX, Dodd-Frank, AML)
6) Weekly Risk Governance Summary
7) Next 7 Days Compliance Deliverable Checklist

RULES:
- Use ONLY information found in this workbook.
- Do NOT invent market data, trade information, or regulatory rules.
- Enforce Canon Guardrails (tblCanonGuardrails) as hard constraints.
- Always reference: TableName + Row_ID(s).
- Output in tables with: ID | Finding | Risk | Impact | \
Guardrail Check | Write-back Location.

NAMED TABLES:
tblTimeline, tblDeliverables, tblDLR, tblClaims, \
tblAssumptions, tblPatchLog, tblCanonGuardrails

GUARDRAILS:
Fictional data only. No real firms, portfolios, or trades. \
No investment advice.

PROVENANCE:
Generated by: DeepSigma v0.4.0 — \
tools/generate_finserv_cds_workbook.py
Framework: Σ OVERWATCH Coherence Ops
Date: {TODAY}
"""


# -------------------------------------------------------------------
# Helpers
# -------------------------------------------------------------------

def _date(offset_days: int) -> str:
    d = datetime.date(2026, 2, 16) + datetime.timedelta(
        days=offset_days,
    )
    return d.isoformat()


def write_rows(ws, rows: list[list]) -> None:
    for r_idx, row in enumerate(rows, 1):
        for c_idx, val in enumerate(row, 1):
            ws.cell(row=r_idx, column=c_idx, value=val)


def add_named_table(ws, name: str, num_rows: int) -> None:
    max_col = ws.max_column
    col_letter = openpyxl.utils.get_column_letter(max_col)
    ref = f"A1:{col_letter}{num_rows + 1}"
    style = TableStyleInfo(
        name="TableStyleMedium9",
        showFirstColumn=False,
        showLastColumn=False,
        showRowStripes=True,
        showColumnStripes=False,
    )
    table = Table(displayName=name, ref=ref)
    table.tableStyleInfo = style
    ws.add_table(table)


def style_header_row(ws) -> None:
    bold = Font(bold=True)
    for cell in ws[1]:
        cell.font = bold
    for col in ws.columns:
        max_len = 0
        col_letter = openpyxl.utils.get_column_letter(
            col[0].column,
        )
        for cell in col:
            val = str(cell.value) if cell.value else ""
            max_len = max(max_len, len(val))
        ws.column_dimensions[col_letter].width = min(
            max_len + 4, 40,
        )


# -------------------------------------------------------------------
# Data generators — FinServ domain
# -------------------------------------------------------------------

def generate_timeline_rows(n: int = 25) -> list[list]:
    headers = [
        "Week", "Start_Date", "End_Date", "Phase",
        "Key_Deliverable", "Primary_Lens", "Decision_ID",
        "Assumption_Check", "Canon_Check", "KPI_Target",
        "Actual_KPI", "Drift_Flag", "CI_Week_Score",
        "CI_Week_Status", "Notes",
    ]
    phases = [
        "Planning", "Execution", "Review",
        "Remediation", "Monitoring",
    ]
    lenses = ["RMC", "REG", "TRD", "FIN", "RMC", "REG"]
    deliverables = [
        "VaR model backtesting report",
        "Basel III capital adequacy review",
        "AML transaction monitoring sweep",
        "SOX internal controls attestation",
        "Counterparty credit limit review",
        "Market risk factor sensitivity analysis",
        "Dodd-Frank trade reporting audit",
        "Liquidity stress test scenario",
        "Operational risk event assessment",
        "Regulatory capital buffer calculation",
    ]
    rows = [headers]
    for i in range(1, n + 1):
        phase = phases[i % len(phases)]
        lens = lenses[i % len(lenses)]
        drift = "GREEN"
        if i % 5 == 0:
            drift = "YELLOW"
        if i % 10 == 0:
            drift = "RED"
        ci = max(60, 95 - (i * 2) % 30)
        ci_s = "ON_TRACK"
        if ci < 85:
            ci_s = "DRIFTING"
        if ci < 70:
            ci_s = "CRITICAL"
        rows.append([
            i, _date((i - 1) * 7), _date(i * 7 - 1),
            phase,
            deliverables[i % len(deliverables)],
            lens, f"DEC-FS-{i:03d}",
            f"ASM-FS-{i:03d}", f"GR-FS-{i:03d}",
            f"Compliance_{85 + i % 10}%",
            f"Compliance_{80 + i % 15}%"
            if i % 3 == 0 else "",
            drift, ci, ci_s, "",
        ])
    return rows


def generate_deliverables_rows(n: int = 25) -> list[list]:
    headers = [
        "Week", "Asset_ID", "Asset_Type", "Channel",
        "Owner", "Status", "Due_Date",
        "Dependency_Decision_ID", "Canon_Guardrail", "Notes",
    ]
    types = [
        "Risk_Report", "Compliance_Filing",
        "Audit_Package", "Model_Validation",
        "Stress_Test", "Policy_Update",
        "Regulatory_Submission", "Control_Assessment",
    ]
    channels = [
        "Risk System", "Compliance Portal",
        "Regulatory Filing", "Audit Dashboard",
        "Treasury", "Trade Surveillance",
        "Board Reporting", "OCC Portal",
    ]
    owners = [
        "CRO", "CCO", "Head_of_Trading",
        "CFO", "Model_Risk_Dir",
    ]
    statuses = ["Draft", "In_Review", "Approved", "Filed"]
    rows = [headers]
    for i in range(1, n + 1):
        rows.append([
            (i - 1) // 3 + 1, f"DLV-FS-{i:03d}",
            types[i % len(types)],
            channels[i % len(channels)],
            owners[i % len(owners)],
            statuses[i % len(statuses)],
            _date(i * 3),
            f"DEC-FS-{i:03d}",
            f"GR-FS-{i:03d}", "",
        ])
    return rows


def generate_dlr_rows(n: int = 25) -> list[list]:
    headers = [
        "Decision_ID", "Initiative_ID", "Decision_Date",
        "Context", "Options_Considered", "Chosen_Option",
        "Rationale_Why", "Rejected_Alternatives_Why",
        "Assumptions_IDs", "Kill_Switch", "Review_Date",
        "Owner", "Status", "Seal_ID",
        "Patch_Version", "Notes",
    ]
    contexts = [
        "VaR limit exception for Equities desk",
        "Counterparty credit limit increase request",
        "AML threshold adjustment for new product",
        "Model risk parameter recalibration",
        "SOX control deficiency remediation",
    ]
    statuses = ["DRAFT", "SEALED", "PATCHED", "RETIRED"]
    owners = [
        "CRO", "CCO", "Head_of_Trading",
        "Model_Risk_Dir", "Internal_Audit",
    ]
    rows = [headers]
    for i in range(1, n + 1):
        desk = DESKS[i % len(DESKS)]
        rows.append([
            f"DEC-FS-{i:03d}",
            f"INIT-FS-{(i - 1) // 5 + 1:03d}",
            _date(i * 2),
            f"{contexts[i % len(contexts)]} — {desk}",
            "A: conservative; B: balanced; C: aggressive",
            "B",
            f"Optimal risk-return balance for "
            f"{desk} desk",
            "A: too restrictive; C: regulatory risk",
            f"ASM-FS-{i:03d};ASM-FS-{(i % 25) + 1:03d}",
            "If VaR breach OR regulatory flag",
            _date(i * 2 + 14),
            owners[i % len(owners)],
            statuses[i % len(statuses)],
            f"SEAL-FS-{i:03d}" if i % 4 != 0 else "",
            i, "",
        ])
    return rows


def generate_claims_rows(n: int = 25) -> list[list]:
    headers = [
        "Claim_ID", "Claim_Text", "Confidence_0_100",
        "Evidence_Summary", "Source_Ref",
        "Last_Validated_Date", "Owner", "Status", "Notes",
    ]
    claims = [
        "VaR model predicts 99th percentile losses "
        "within 10% of actuals",
        "Counterparty default probability models "
        "validated quarterly",
        "AML monitoring covers 100% of "
        "high-risk transactions",
        "Liquidity buffer exceeds 30-day "
        "stress scenario requirement",
        "Operational risk capital charge below "
        "regulatory threshold",
    ]
    statuses = [
        "ACTIVE", "ACTIVE", "ACTIVE",
        "EXPIRED", "CONTESTED",
    ]
    rows = [headers]
    for i in range(1, n + 1):
        conf = max(40, 95 - (i * 3) % 50)
        desk = DESKS[i % len(DESKS)]
        rows.append([
            f"CLM-FS-{i:03d}",
            claims[i % len(claims)],
            conf,
            f"Based on Q4 2025 backtest for {desk}",
            f"risk_report_Q4_{2025 + i % 2}",
            _date(i),
            "Head_of_Risk",
            statuses[i % len(statuses)], "",
        ])
    return rows


def generate_assumptions_rows(n: int = 25) -> list[list]:
    headers = [
        "Assumption_ID", "Related_Decision_ID",
        "Assumption_Text", "Confidence_Initial_0_1",
        "Half_Life_Days", "Date_Validated_Last",
        "Current_Confidence", "Expiry_Date", "Status",
        "Owner", "Action_If_Expired", "Notes",
    ]
    assumptions = [
        "Interest rate curve shape stable for "
        "next 30 days",
        "Equity-credit correlation within "
        "historical 2-sigma band",
        "Liquidity conditions normal for "
        "G10 currencies",
        "Counterparty default rates within "
        "model-predicted range",
        "Regulatory capital requirements "
        "unchanged this quarter",
    ]
    rows = [headers]
    for i in range(1, n + 1):
        ci = round(0.6 + (i % 4) * 0.1, 2)
        hl = 14 + (i % 5) * 7
        st = "ACTIVE"
        if i % 4 == 0:
            st = "EXPIRED"
        if i % 8 == 0:
            st = "REFRESHED"
        rows.append([
            f"ASM-FS-{i:03d}", f"DEC-FS-{i:03d}",
            assumptions[i % len(assumptions)],
            ci, hl, _date(i),
            round(
                ci * (0.5 ** (max(0, i - 10) / hl)), 2,
            ),
            _date(i + hl), st,
            "Head_of_Risk",
            "Recalibrate with current market data", "",
        ])
    return rows


def generate_patch_rows(n: int = 25) -> list[list]:
    headers = [
        "Patch_ID", "Week_Triggered", "Decision_ID",
        "Drift_Source", "Severity", "Root_Cause",
        "Patch_Action", "Owner", "Status",
        "Date_Opened", "Date_Closed",
        "Impact_on_CI", "Notes",
    ]
    drift_sources = [
        "VaR model backtesting breach",
        "Counterparty limit utilization > 90%",
        "AML alert backlog growing",
        "SOX control test failure",
        "Liquidity ratio approaching minimum",
    ]
    root_causes = [
        "Market regime shift not captured by model",
        "Concentration risk in single counterparty",
        "Alert tuning parameters stale",
        "Process change not reflected in controls",
        "Stress scenario assumptions outdated",
    ]
    actions = [
        "Recalibrate VaR model parameters",
        "Reduce counterparty exposure + increase "
        "collateral",
        "Retune AML thresholds + clear backlog",
        "Remediate control gap + retest",
        "Update stress scenarios with current data",
    ]
    p_statuses = ["OPEN", "IN_PROGRESS", "CLOSED"]
    severities = ["LOW", "MEDIUM", "HIGH", "CRITICAL"]
    rows = [headers]
    for i in range(1, n + 1):
        st = p_statuses[i % len(p_statuses)]
        rows.append([
            f"PAT-FS-{i:03d}",
            (i - 1) // 3 + 1,
            f"DEC-FS-{i:03d}",
            drift_sources[i % len(drift_sources)],
            severities[i % len(severities)],
            root_causes[i % len(root_causes)],
            actions[i % len(actions)],
            "Risk_Analyst",
            st, _date(i * 2),
            _date(i * 2 + 5) if st == "CLOSED" else "",
            f"CI +{3 + i % 8} pts"
            if st == "CLOSED" else "",
            "",
        ])
    return rows


def generate_canon_rows(n: int = 25) -> list[list]:
    headers = [
        "Guardrail_ID", "Character", "Dimension",
        "Allowed", "Restricted", "Forbidden",
        "Severity", "Detection_Method", "Auto_Flag_If",
        "Owner", "Escalation_Path", "Notes",
    ]
    entities = [
        "VaR Limit", "Counterparty Exposure",
        "AML Threshold", "Capital Buffer",
        "Liquidity Ratio", "Leverage Ratio",
        "Concentration Limit", "Trading Authority",
        "SOX Control", "Margin Requirement",
    ]
    dimensions = [
        "Regulatory", "Risk", "Compliance", "Conduct",
    ]
    rows = [headers]
    for i in range(1, n + 1):
        ent = entities[i % len(entities)]
        dim = dimensions[i % len(dimensions)]
        sev = "HARD"
        if i % 3 != 0:
            sev = "ADVISORY"
        if i % 7 == 0:
            sev = "CRITICAL"
        rows.append([
            f"GR-FS-{i:03d}", ent, dim,
            f"{ent} within {dim.lower()} standards",
            f"{ent} exception without CRO approval",
            f"{ent} breach without immediate "
            f"escalation",
            sev, "Automated surveillance + review",
            f"Contains '{ent}' + breach keyword",
            "Chief_Risk_Officer",
            "CRO → Board Risk Committee → Regulator",
            "",
        ])
    return rows


# -------------------------------------------------------------------
# Utility sheet stubs
# -------------------------------------------------------------------

def _build_utility_sheets(wb: Workbook) -> None:
    qs = wb.create_sheet("QUICK_START")
    write_rows(qs, [
        ["Step", "Do this", "Where",
         "Output", "Notes"],
        [1, "Read BOOT!A1", "BOOT",
         "Context loaded", "LLM reads this first"],
        [2, "Review risk governance",
         "BRIEF_MATRIX",
         "Timeline object", "Weekly milestones"],
        [3, "Check deliverables", "DELIVERABLES",
         "Filing status", "Regulatory submissions"],
        [4, "Capture decision", "DLR_CAPTURE",
         "Sealed DLR", "Link assumptions"],
        [5, "Register assumptions", "ASSUMPTIONS",
         "Half-life tracking", "Set expiry"],
        [6, "Check CI dashboard", "CI_DASHBOARD",
         "Coherence Index", "Monitor drift"],
    ])

    dd = wb.create_sheet("DATA_DICTIONARY")
    write_rows(dd, [
        ["List_Name", "Value"],
        ["Domains", "RMC"], ["Domains", "REG"],
        ["Domains", "TRD"], ["Domains", "FIN"],
        ["Desks", "Equities"],
        ["Desks", "Fixed Income"],
        ["Desks", "Derivatives"],
        ["DLR_Status", "DRAFT"],
        ["DLR_Status", "SEALED"],
        ["DLR_Status", "PATCHED"],
        ["DLR_Status", "RETIRED"],
        ["Canon_Type", "HARD"],
        ["Canon_Type", "CRITICAL"],
        ["Canon_Type", "ADVISORY"],
        ["Severity", "RED"],
        ["Severity", "YELLOW"],
        ["Severity", "GREEN"],
    ])

    lp = wb.create_sheet("6_LENS_PROMPTS")
    write_rows(lp, [
        ["Lens", "IntelOps", "ReOps",
         "FranOps", "Generated_Prompt"],
        ["RMC", "Risk exposure truth?",
         "Model governance?",
         "Limit management?", ""],
        ["REG", "Regulatory compliance?",
         "Basel/SOX/Dodd-Frank?",
         "Filing deadlines?", ""],
        ["TRD", "Trading drift?",
         "Execution quality?",
         "Position limits?", ""],
        ["FIN", "P&L accuracy?",
         "Capital adequacy?",
         "Funding cost assumptions?", ""],
        ["CONDUCT", "Conduct risk?",
         "Conflict of interest?",
         "Surveillance gaps?", ""],
        ["MODEL", "Model performance?",
         "Backtesting results?",
         "Validation status?", ""],
    ])

    ci = wb.create_sheet("CI_DASHBOARD")
    write_rows(ci, [
        ["Dimension", "Weight", "Score (0-100)",
         "Weighted", "Notes", "Source"],
        ["Drift Velocity", 0.20, "", "",
         "Unresolved risk/compliance drift signals",
         "PATCH_LOG"],
        ["Assumption Freshness", 0.15, "", "",
         "% of assumptions within half-life",
         "ASSUMPTIONS"],
        ["Claim Confidence", 0.15, "", "",
         "Avg confidence across active claims",
         "CLAIMS"],
        ["DLR Completeness", 0.15, "", "",
         "% of decisions with full rationale",
         "DLR_CAPTURE"],
        ["Canon Compliance", 0.10, "", "",
         "% passing regulatory guardrail checks",
         "CANON_SYNC"],
        ["Deliverable On-Time", 0.10, "", "",
         "% of filings delivered by deadline",
         "BRIEF_MATRIX"],
        ["Patch Resolution", 0.05, "", "",
         "% of patches closed within SLA",
         "PATCH_LOG"],
        ["Evidence Coverage", 0.05, "", "",
         "% of claims with evidence attached",
         "CLAIMS"],
        ["Owner Assignment", 0.03, "", "",
         "% of rows with assigned owner",
         "ALL"],
        ["Review Cadence", 0.02, "", "",
         "% of DLRs reviewed within date",
         "DLR_CAPTURE"],
    ])


# -------------------------------------------------------------------
# Main
# -------------------------------------------------------------------

def generate_workbook(output_path: Path) -> None:
    """Generate the FinServ CDS workbook."""
    wb = Workbook()
    wb.remove(wb.active)

    # BOOT sheet
    boot = wb.create_sheet("BOOT")
    boot["A1"] = BOOT_TEXT
    boot["A1"].alignment = Alignment(
        wrap_text=True, vertical="top",
    )
    boot["A1"].font = Font(name="Consolas", size=11)
    boot.column_dimensions["A"].width = 120
    boot.row_dimensions[1].height = 800

    # Utility sheets
    _build_utility_sheets(wb)

    # Governance sheets with 25 rows + named tables
    bm = wb.create_sheet("BRIEF_MATRIX")
    write_rows(bm, generate_timeline_rows(25))
    style_header_row(bm)
    add_named_table(bm, "tblTimeline", 25)

    dl = wb.create_sheet("DELIVERABLES")
    write_rows(dl, generate_deliverables_rows(25))
    style_header_row(dl)
    add_named_table(dl, "tblDeliverables", 25)

    dlr = wb.create_sheet("DLR_CAPTURE")
    write_rows(dlr, generate_dlr_rows(25))
    style_header_row(dlr)
    add_named_table(dlr, "tblDLR", 25)

    cl = wb.create_sheet("CLAIMS")
    write_rows(cl, generate_claims_rows(25))
    style_header_row(cl)
    add_named_table(cl, "tblClaims", 25)

    asm = wb.create_sheet("ASSUMPTIONS")
    write_rows(asm, generate_assumptions_rows(25))
    style_header_row(asm)
    add_named_table(asm, "tblAssumptions", 25)

    pl = wb.create_sheet("PATCH_LOG")
    write_rows(pl, generate_patch_rows(25))
    style_header_row(pl)
    add_named_table(pl, "tblPatchLog", 25)

    cs = wb.create_sheet("CANON_SYNC")
    write_rows(cs, generate_canon_rows(25))
    style_header_row(cs)
    add_named_table(cs, "tblCanonGuardrails", 25)

    # Move BOOT to front
    wb.move_sheet("BOOT", offset=-(len(wb.sheetnames) - 1))

    # Save
    output_path.parent.mkdir(parents=True, exist_ok=True)
    wb.save(str(output_path))
    print(f"FinServ workbook saved: {output_path}")
    print(f"  Sheets: {wb.sheetnames}")
    tables = []
    for ws in wb.worksheets:
        for t in ws.tables.values():
            tables.append(t.displayName)
    print(f"  Named tables: {', '.join(tables)}")


def main() -> None:
    generate_workbook(OUTPUT)


if __name__ == "__main__":
    main()
